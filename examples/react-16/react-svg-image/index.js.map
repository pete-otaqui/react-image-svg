{"version":3,"sources":["../src/index.ts"],"sourcesContent":["export interface RenderAsPromise {\n  (el: JSX.Element, domEl: HTMLElement): Promise<void>;\n}\n\nexport enum ImageFormat {\n  PNG = \"png\",\n  JPEG = \"jpeg\",\n  WEBP = \"webp\",\n}\n\nexport enum ImageOutput {\n  DATA_URL = \"data_url\",\n  BLOB = \"blob\",\n}\n\nexport type RenderSvgAsImageOptions = {\n  format?: ImageFormat;\n  output?: ImageOutput;\n  injectSelector?: string;\n  ignoreAllSelectors?: string[];\n  scale?: number;\n  quality?: number;\n  throwErrors?: boolean;\n};\n\nconst INJECTOR_CONTAINER_ATTRIBUTE = \"data-react-svg-image-injector-container\";\n\nlet renderAsPromise: RenderAsPromise;\n/**\n * Call this function first, passing in your own render function.\n * \n * The argument you pass in should perform the correct ReactDOM render call,\n * and resolve to a promise when the render is complete.\n * \n * Example for React 16 an 17:\n * ```js\n * async function renderAsPromise(el, domEl) {\n *   return new Promise((resolve) => {\n *     ReactDOM.render(el, domEl, resolve);\n *   });\n * }\n * ```\n * \n * Example for React 18:\n * ```js\n * async function renderAsPromise(el, domEl) {\n *   const root = ReactDOM.createRoot(domEl);\n *   root.render(el);\n *   return new Promise((resolve) => {\n *     requestIdleCallback(resolve);\n *   });\n * }\n * ```\n */\nexport function setDomRenderer(renderer: RenderAsPromise) {\n  renderAsPromise = renderer;\n}\n\n/**\n * Render a React SVG element as an image, returning a promise that resolves to\n * either a data URL or a Blob.\n *\n * You can configure the quality (default is 97), and the output format (from\n * PNG which is the default, JPEG or WEBP).\n * \n * This function will trigger a whole new \"react app\" to render your component,\n * so you won't be able to use any Contexts that are not in the JSX.Element you\n * pass in.\n * \n * By default the new react app will be rendered on the body element, but you can\n * pass in a CSS Selector for a different element if you prefer.\n */\nexport async function renderSvgAsImage(\n  el: JSX.Element,\n  {\n    format = ImageFormat.PNG,\n    injectSelector = \"body\",\n    output = ImageOutput.DATA_URL,\n    scale = 1,\n    quality = 0.97,\n    throwErrors = true,\n    ignoreAllSelectors = [],\n  }: RenderSvgAsImageOptions = {}\n): Promise<string | Blob> {\n  try {\n    if (!renderAsPromise) {\n      throw new Error(\n        \"You must call setDomRenderer before calling renderSvgAsImage\"\n      );\n    }\n    const renderId = uuidv4();\n    const injectorRoot = document.querySelector(injectSelector);\n    if (!injectorRoot) {\n      throw new Error(`Could not find element with selector ${injectorRoot}`);\n    }\n    if (!Object.values(ImageFormat).includes(format)) {\n      throw new Error(`Invalid image format ${format}`);\n    }\n    if (!Object.values(ImageOutput).includes(output)) {\n      throw new Error(`Invalid image output ${output}`);\n    }\n    const injectorContainer = getInjectorContainer(injectorRoot, renderId);\n\n    try {\n      await renderAsPromise(el, injectorContainer);\n    } catch (e) {\n      removeInjectorContainer(injectorRoot, renderId);\n      console.error(\"Failed to render element\");\n      throw e;\n    }\n\n    const renderedSvg = injectorContainer.querySelector(\"svg\");\n    if (!renderedSvg) {\n      removeInjectorContainer(injectorRoot, renderId);\n      throw new Error(\"Could not find a rendered SVG\");\n    }\n\n    normaliseSvg(renderedSvg, ignoreAllSelectors);\n\n    const canvas = await copyToCanvas(renderedSvg, scale);\n    let returnValue = toOutput(canvas, output, format, quality);\n\n    removeInjectorContainer(injectorRoot, renderId);\n\n    return returnValue;\n  } catch (e) {\n    if (throwErrors) {\n      throw e;\n    } else {\n      console.error(e);\n      return \"\";\n    }\n  }\n}\n\n/**\n * Create a new container we will use to render the app in, inside the\n * injectorRoot element (default is `document.body`)\n */\nfunction getInjectorContainer(injectorRoot: Element, renderId: string) {\n  const injectorContainer = document.createElement(\"div\");\n  injectorContainer.setAttribute(\n    \"data-react-svg-image-injector-container\",\n    renderId\n  );\n  injectorContainer.style.visibility = \"hidden\";\n  injectorContainer.style.position = \"absolute\";\n  injectorContainer.style.top = \"0\";\n  injectorContainer.style.left = \"0\";\n  injectorRoot.appendChild(injectorContainer);\n  return injectorContainer;\n}\n\n/**\n * Remove the container that we added to the root\n */\nfunction removeInjectorContainer(injectorRoot: Element, renderId: string) {\n  const injectorContainer = injectorRoot.querySelector(\n    `[${INJECTOR_CONTAINER_ATTRIBUTE}=\"${renderId}\"]`\n  );\n  if (injectorContainer) {\n    injectorRoot.removeChild(injectorContainer);\n  } else {\n    console.error(`Could not find injector container with id ${renderId}`);\n  }\n}\n\n/**\n * Get a UUID, used to identify the container we are rendering in\n */\nfunction uuidv4(): string {\n  // @ts-ignore\n  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>\n    (\n      c ^\n      (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))\n    ).toString(16)\n  );\n}\n\n/**\n * Normalise an SVG by removing any elements requested, and inlining styles.\n */\nfunction normaliseSvg(svg: SVGSVGElement, ignoreAllSelectors: string[]) {\n  // Strip out elements we don't want\n  ignoreAllSelectors.forEach(selector => {\n    const els = svg.querySelectorAll(selector);\n    for (let i = 0; i < els.length; i++) {\n      els[i].parentNode?.removeChild(els[i]);\n    }\n  });\n  // Inline all styles, mutating original since it's already a clone\n  inlineStyles(svg, svg);\n}\n\n/**\n * Inline all computed styles on an element, and all its children\n */\nfunction inlineStyles(source: SVGElement, target: SVGElement) {\n  // inline style from source element to the target (detached) one\n  const computed = window.getComputedStyle(source);\n  for (const styleKey of <any>computed) {\n    if (styleKey === \"visibility\") {\n      continue;\n    }\n    (<any>target.style)[styleKey] = (<any>computed)[styleKey];\n  }\n\n  // recursively call inlineStyles for the element children\n  for (let i = 0; i < source.children.length; i++) {\n    inlineStyles(\n      source.children[i] as SVGElement,\n      target.children[i] as SVGElement\n    );\n  }\n}\n\n/**\n * Take a an `<svg />` element, and make it display on a `<canvas />`\n */\nfunction copyToCanvas(\n  source: SVGElement,\n  scale: number\n): Promise<HTMLCanvasElement> {\n  let svgData = new XMLSerializer().serializeToString(source);\n  let canvas = document.createElement(\"canvas\");\n  let svgSize = source.getBoundingClientRect();\n\n  //Resize can break shadows\n  canvas.width = svgSize.width * scale;\n  canvas.height = svgSize.height * scale;\n  canvas.style.width = `${svgSize.width}px`;\n  canvas.style.height = `${svgSize.height}px`;\n\n\n  let ctxt = canvas.getContext(\"2d\");\n  if (!ctxt) {\n    throw new Error(\"Could not get canvas context\");\n  }\n  ctxt.scale(scale, scale);\n\n  let img = document.createElement(\"img\");\n  img.setAttribute(\n    \"src\",\n    \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svgData)))\n  );\n  return new Promise((resolve) => {\n    img.onload = () => {\n      if (!ctxt) {\n        throw new Error(\"Could not get canvas context\");\n      }\n      ctxt.drawImage(img, 0, 0);\n      resolve(canvas);\n    };\n  });\n}\n\n/**\n * Convert a canvas to the appropriate output format\n */\nasync function toOutput(\n  canvas: HTMLCanvasElement,\n  output: ImageOutput,\n  format: ImageFormat,\n  quality: number\n): Promise<string | Blob> {\n  if (output === ImageOutput.DATA_URL) {\n    return toDataUrl(canvas, format, quality);\n  } else {\n    const blob = await toBlob(canvas, format, quality);\n    if (!blob) {\n      throw new Error(\"Could not convert canvas to blob\");\n    }\n    return blob;\n  }\n}\n\n/**\n * Convert a canvas to a data url\n */\nfunction toDataUrl(\n  canvas: HTMLCanvasElement,\n  format: ImageFormat,\n  quality: number\n): string {\n  return canvas.toDataURL(`image/${format}`, quality);\n}\n\n/**\n * Convert a canvas to a blob\n */\nfunction toBlob(\n  canvas: HTMLCanvasElement,\n  format: ImageFormat,\n  quality: number\n): Promise<Blob | null> {\n  return new Promise((resolve) => {\n    canvas.toBlob((blob) => resolve(blob), `image/${format}`, quality);\n  });\n}\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,iBAAAE,EAAA,gBAAAC,EAAA,qBAAAC,EAAA,mBAAAC,IAAA,eAAAC,EAAAN,GAIO,IAAKE,OACVA,EAAA,IAAM,MACNA,EAAA,KAAO,OACPA,EAAA,KAAO,OAHGA,OAAA,IAMAC,OACVA,EAAA,SAAW,WACXA,EAAA,KAAO,OAFGA,OAAA,IAeNI,EAA+B,0CAEjCC,EA2BG,SAASH,EAAeI,EAA2B,CACxDD,EAAkBC,CACpB,CAgBA,eAAsBL,EACpBM,EACA,CACE,OAAAC,EAAS,MACT,eAAAC,EAAiB,OACjB,OAAAC,EAAS,WACT,MAAAC,EAAQ,EACR,QAAAC,EAAU,IACV,YAAAC,EAAc,GACd,mBAAAC,EAAqB,CAAC,CACxB,EAA6B,CAAC,EACN,CACxB,GAAI,CACF,GAAI,CAACT,EACH,MAAM,IAAI,MACR,8DACF,EAEF,IAAMU,EAAWC,EAAO,EAClBC,EAAe,SAAS,cAAcR,CAAc,EAC1D,GAAI,CAACQ,EACH,MAAM,IAAI,MAAM,wCAAwCA,GAAc,EAExE,GAAI,CAAC,OAAO,OAAOlB,CAAW,EAAE,SAASS,CAAM,EAC7C,MAAM,IAAI,MAAM,wBAAwBA,GAAQ,EAElD,GAAI,CAAC,OAAO,OAAOR,CAAW,EAAE,SAASU,CAAM,EAC7C,MAAM,IAAI,MAAM,wBAAwBA,GAAQ,EAElD,IAAMQ,EAAoBC,EAAqBF,EAAcF,CAAQ,EAErE,GAAI,CACF,MAAMV,EAAgBE,EAAIW,CAAiB,CAC7C,OAASE,EAAP,CACA,MAAAC,EAAwBJ,EAAcF,CAAQ,EAC9C,QAAQ,MAAM,0BAA0B,EAClCK,CACR,CAEA,IAAME,EAAcJ,EAAkB,cAAc,KAAK,EACzD,GAAI,CAACI,EACH,MAAAD,EAAwBJ,EAAcF,CAAQ,EACxC,IAAI,MAAM,+BAA+B,EAGjDQ,EAAaD,EAAaR,CAAkB,EAE5C,IAAMU,EAAS,MAAMC,EAAaH,EAAaX,CAAK,EAChDe,EAAcC,EAASH,EAAQd,EAAQF,EAAQI,CAAO,EAE1D,OAAAS,EAAwBJ,EAAcF,CAAQ,EAEvCW,CACT,OAASN,EAAP,CACA,GAAIP,EACF,MAAMO,EAEN,eAAQ,MAAMA,CAAC,EACR,EAEX,CACF,CAMA,SAASD,EAAqBF,EAAuBF,EAAkB,CACrE,IAAMG,EAAoB,SAAS,cAAc,KAAK,EACtD,OAAAA,EAAkB,aAChB,0CACAH,CACF,EACAG,EAAkB,MAAM,WAAa,SACrCA,EAAkB,MAAM,SAAW,WACnCA,EAAkB,MAAM,IAAM,IAC9BA,EAAkB,MAAM,KAAO,IAC/BD,EAAa,YAAYC,CAAiB,EACnCA,CACT,CAKA,SAASG,EAAwBJ,EAAuBF,EAAkB,CACxE,IAAMG,EAAoBD,EAAa,cACrC,IAAIb,MAAiCW,KACvC,EACIG,EACFD,EAAa,YAAYC,CAAiB,EAE1C,QAAQ,MAAM,6CAA6CH,GAAU,CAEzE,CAKA,SAASC,GAAiB,CAExB,OAAQ,CAAC,GAAG,EAAI,KAAO,KAAO,KAAO,OAAO,QAAQ,SAAWY,IAE3DA,EACC,OAAO,gBAAgB,IAAI,WAAW,CAAC,CAAC,EAAE,GAAM,IAAOA,EAAI,GAC5D,SAAS,EAAE,CACf,CACF,CAKA,SAASL,EAAaM,EAAoBf,EAA8B,CAEtEA,EAAmB,QAAQgB,GAAY,CAzLzC,IAAAC,EA0LI,IAAMC,EAAMH,EAAI,iBAAiBC,CAAQ,EACzC,QAAS,EAAI,EAAG,EAAIE,EAAI,OAAQ,KAC9BD,EAAAC,EAAI,GAAG,aAAP,MAAAD,EAAmB,YAAYC,EAAI,GAEvC,CAAC,EAEDC,EAAaJ,EAAKA,CAAG,CACvB,CAKA,SAASI,EAAaC,EAAoBC,EAAoB,CAE5D,IAAMC,EAAW,OAAO,iBAAiBF,CAAM,EAC/C,QAAWG,KAAiBD,EACtBC,IAAa,eAGXF,EAAO,MAAOE,GAAkBD,EAAUC,IAIlD,QAASC,EAAI,EAAGA,EAAIJ,EAAO,SAAS,OAAQI,IAC1CL,EACEC,EAAO,SAASI,GAChBH,EAAO,SAASG,EAClB,CAEJ,CAKA,SAASb,EACPS,EACAvB,EAC4B,CAC5B,IAAI4B,EAAU,IAAI,cAAc,EAAE,kBAAkBL,CAAM,EACtDV,EAAS,SAAS,cAAc,QAAQ,EACxCgB,EAAUN,EAAO,sBAAsB,EAG3CV,EAAO,MAAQgB,EAAQ,MAAQ7B,EAC/Ba,EAAO,OAASgB,EAAQ,OAAS7B,EACjCa,EAAO,MAAM,MAAQ,GAAGgB,EAAQ,UAChChB,EAAO,MAAM,OAAS,GAAGgB,EAAQ,WAGjC,IAAIC,EAAOjB,EAAO,WAAW,IAAI,EACjC,GAAI,CAACiB,EACH,MAAM,IAAI,MAAM,8BAA8B,EAEhDA,EAAK,MAAM9B,EAAOA,CAAK,EAEvB,IAAI+B,EAAM,SAAS,cAAc,KAAK,EACtC,OAAAA,EAAI,aACF,MACA,6BAA+B,KAAK,SAAS,mBAAmBH,CAAO,CAAC,CAAC,CAC3E,EACO,IAAI,QAASI,GAAY,CAC9BD,EAAI,OAAS,IAAM,CACjB,GAAI,CAACD,EACH,MAAM,IAAI,MAAM,8BAA8B,EAEhDA,EAAK,UAAUC,EAAK,EAAG,CAAC,EACxBC,EAAQnB,CAAM,CAChB,CACF,CAAC,CACH,CAKA,eAAeG,EACbH,EACAd,EACAF,EACAI,EACwB,CACxB,GAAIF,IAAW,WACb,OAAOkC,EAAUpB,EAAQhB,EAAQI,CAAO,EACnC,CACL,IAAMiC,EAAO,MAAMC,EAAOtB,EAAQhB,EAAQI,CAAO,EACjD,GAAI,CAACiC,EACH,MAAM,IAAI,MAAM,kCAAkC,EAEpD,OAAOA,CACT,CACF,CAKA,SAASD,EACPpB,EACAhB,EACAI,EACQ,CACR,OAAOY,EAAO,UAAU,SAAShB,IAAUI,CAAO,CACpD,CAKA,SAASkC,EACPtB,EACAhB,EACAI,EACsB,CACtB,OAAO,IAAI,QAAS+B,GAAY,CAC9BnB,EAAO,OAAQqB,GAASF,EAAQE,CAAI,EAAG,SAASrC,IAAUI,CAAO,CACnE,CAAC,CACH","names":["src_exports","__export","ImageFormat","ImageOutput","renderSvgAsImage","setDomRenderer","__toCommonJS","INJECTOR_CONTAINER_ATTRIBUTE","renderAsPromise","renderer","el","format","injectSelector","output","scale","quality","throwErrors","ignoreAllSelectors","renderId","uuidv4","injectorRoot","injectorContainer","getInjectorContainer","e","removeInjectorContainer","renderedSvg","normaliseSvg","canvas","copyToCanvas","returnValue","toOutput","c","svg","selector","_a","els","inlineStyles","source","target","computed","styleKey","i","svgData","svgSize","ctxt","img","resolve","toDataUrl","blob","toBlob"]}